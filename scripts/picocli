#!/usr/bin/env python
#
# Copyright (C) 2018-2019 Pico Technology Ltd. See LICENSE file for terms.
# Copyright (C) 2019 Xiphos Systems Corp.
#
# PS3000a Series STREAMING MODE EXAMPLE
# This example demonstrates how to call the ps3000A driver API functions in
# order to open a device, setup 2 channels and collects streamed data (1 buffer).
# This data is then plotted as mV against time in ns.

import time
import ctypes
import argparse
import numpy as np

from picosdk.constants import PICO_STATUS
from picosdk.functions import adc2mV, assert_pico_ok
from picosdk.ps3000a import ps3000a as ps
import matplotlib.pyplot as plt


class Picoscope:
    def __init__(self, serial=None):
        # Create chandle and status ready for use
        self.chandle = ctypes.c_int16()
        serial = ctypes.c_char_p(serial)

        # Open PicoScope 3000 Series device
        open_status = ps.ps3000aOpenUnit(ctypes.byref(self.chandle), serial)
        if self.chandle == -1:
            raise Exception('Failed to open scope')
        elif self.chandle == 0:
            raise Exception('Scope not found')
        # External power not found, switch to USB power
        if open_status == PICO_STATUS['PICO_POWER_SUPPLY_NOT_CONNECTED']:
            assert ps.ps3000aChangePowerSource(chandle, open_status) == 0, \
                    'Failed change power source'

    def __del__(self):
        # Stop scope from sampling data and close
        assert_pico_ok(ps.ps3000aStop(self.chandle))
        assert_pico_ok(ps.ps3000aCloseUnit(self.chandle))


def parse_cmdline():
    parser = argparse.ArgumentParser(description='Script to command a Picoscope 3000')
    parser.add_argument('--channel', default='A',
                        choices=['A', 'B', 'C', 'D'],
                        help='Set channel to sample',
    )

    ch_opts = parser.add_argument_group('channel options')
    ch_opts.add_argument('--range', default='2V',
                         choices=['10MV', '20MV', '50MV', '100MV', '200MV',
                                  '500MV', '1V', '2V', '5V', '10V', '20V',
                                  '50V'],
                         help='Set channel range',
    )
    ch_opts.add_argument('--coupling', default='DC',
                         choices=['AC', 'DC'],
                         help='Set channel coupling',
    )

    acq_opts = parser.add_argument_group('acquisition options')
    acq_opts.add_argument('--sampling-interval', type=int, default=250,
                          help='requested time interval between samples, in units of --time-unit',
    )
    acq_opts.add_argument('--time-unit', default='us',
                         choices=['fs', 'ps', 'ns', 'us', 'ms', 's'],
                         help='time unit used for sampling intervall',
    )

    options = parser.parse_args()
    options.channel = ps.PS3000A_CHANNEL[f'PS3000A_CHANNEL_{options.channel}']
    options.range = ps.PS3000A_RANGE[f'PS3000A_{options.range}']
    options.coupling = ps.PS3000A_COUPLING[f'PS3000A_{options.coupling}']
    options.sampling_interval = ctypes.c_int32(options.sampling_interval)

    return options


def streaming_callback(handle, noOfSamples, startIndex, overflow, triggerAt, triggered, autoStop, param):
    global nextSample, autoStopOuter, wasCalledBack
    wasCalledBack = True
    destEnd = nextSample + noOfSamples
    sourceEnd = startIndex + noOfSamples
    bufferCompleteA[nextSample:destEnd] = data_buffer[startIndex:sourceEnd]
    nextSample += noOfSamples
    if autoStop:
        autoStopOuter = True


if __name__ == '__main__':
    options = parse_cmdline()

    pico = Picoscope()

    assert ps.ps3000aSetChannel(pico.chandle,
                                options.channel,
                                1,
                                options.coupling,
                                options.range,
                                0.0) == 0, 'Failed to setup Channel'

    # Size of capture
    sizeOfOneBuffer = 500
    numBuffersToCapture = 1000

    totalSamples = sizeOfOneBuffer * numBuffersToCapture

    # Create buffers ready for assigning pointers for data collection
    data_buffer = np.zeros(shape=sizeOfOneBuffer, dtype=np.int16)

    assert ps.ps3000aSetDataBuffer(pico.chandle,
                                   options.channel,
                                   data_buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int16)),
                                   sizeOfOneBuffer,
                                   0,
                                   ps.PS3000A_RATIO_MODE['PS3000A_RATIO_MODE_NONE']) == 0, \
            f'Failed to set data buffers for channel {options.channel}'

    # Begin streaming mode:
    # We are not triggering:
    maxPreTriggerSamples = 0
    autoStopOn = 1
    # No downsampling:
    downsampleRatio = 1
    assert ps.ps3000aRunStreaming(pico.chandle,
                                  ctypes.byref(options.sampling_interval),
                                  ps.PS3000A_TIME_UNITS[f'PS3000A_{options.time_unit.upper()}'],
                                  maxPreTriggerSamples,
                                  totalSamples,
                                  autoStopOn,
                                  1,
                                  ps.PS3000A_RATIO_MODE['PS3000A_RATIO_MODE_NONE'],
                                  sizeOfOneBuffer) == 0, 'Failed to start streaming'

    # on return, RunStreaming updates sampling_interval to the actual rate
    print(f'Actual sampling interval: {options.sampling_interval.value} {options.time_unit}')

    # We need a big buffer, not registered with the driver, to keep our complete capture in.
    bufferCompleteA = np.zeros(shape=totalSamples, dtype=np.int16)
    nextSample = 0
    autoStopOuter = False
    wasCalledBack = False


    # Convert the python function into a C function pointer.
    cFuncPtr = ps.StreamingReadyType(streaming_callback)

    # Fetch data from the driver in a loop, copying it out of the registered buffers and into our complete one.
    while nextSample < totalSamples and not autoStopOuter:
        wasCalledBack = False
        ps.ps3000aGetStreamingLatestValues(pico.chandle, cFuncPtr, None)
        if not wasCalledBack:
            # If we weren't called back by the driver, this means no data is ready. Sleep for a short while before trying
            # again.
            time.sleep(0.01)

    print("Done grabbing values.")

    # Find maximum ADC count value
    # handle = pico.chandle
    # pointer to value = ctypes.byref(maxADC)
    maxADC = ctypes.c_int16()
    assert ps.ps3000aMaximumValue(pico.chandle, ctypes.byref(maxADC)) == 0, 'Failed to find max'

    # Convert ADC counts data to mV
    adc2mVChAMax = adc2mV(bufferCompleteA, options.range, maxADC)

    # Create time data
    time = np.linspace(0, (totalSamples) * options.sampling_interval.value, totalSamples)

    # Plot data from channel A
    plt.plot(time, adc2mVChAMax[:])
    plt.xlabel(f'Time ({options.time_unit})')
    plt.ylabel('Voltage (mV)')
    plt.savefig('out.png')
