#!/usr/bin/env python
#
# Copyright (C) 2018-2019 Pico Technology Ltd. See LICENSE file for terms.
# Copyright (C) 2019 Xiphos Systems Corp.
#
# PS3000a Series STREAMING MODE EXAMPLE
# This example demonstrates how to call the ps3000A driver API functions in
# order to open a device, setup 2 channels and collects streamed data (1 buffer).
# This data is then plotted as mV against time in ns.

import time
import ctypes
import argparse
import numpy as np

from picosdk.functions import adc2mV, assert_pico_ok
from picosdk.ps3000a import ps3000a as ps
import matplotlib.pyplot as plt


def parse_cmdline():
    parser = argparse.ArgumentParser(description='Script to command a Picoscope 3000')
    parser.add_argument('--channel', default='A',
                        choices=['A', 'B', 'C', 'D'],
                        help='Set channel to sample',
    )

    ch_opts = parser.add_argument_group('channel options')
    ch_opts.add_argument('--range', default='2V',
                         choices=['10MV', '20MV', '50MV', '100MV', '200MV',
                                  '500MV', '1V', '2V', '5V', '10V', '20V',
                                  '50V'],
                         help='Set channel range',
    )
    ch_opts.add_argument('--coupling', default='DC',
                         choices=['AC', 'DC'],
                         help='Set channel coupling',
    )

    options = parser.parse_args()
    options.channel = ps.PS3000A_CHANNEL[f'PS3000A_CHANNEL_{options.channel}']
    options.range = ps.PS3000A_RANGE[f'PS3000A_{options.range}']
    options.coupling = ps.PS3000A_COUPLING[f'PS3000A_{options.coupling}']

    return options


def streaming_callback(handle, noOfSamples, startIndex, overflow, triggerAt, triggered, autoStop, param):
    global nextSample, autoStopOuter, wasCalledBack
    wasCalledBack = True
    destEnd = nextSample + noOfSamples
    sourceEnd = startIndex + noOfSamples
    bufferCompleteA[nextSample:destEnd] = bufferAMax[startIndex:sourceEnd]
    nextSample += noOfSamples
    if autoStop:
        autoStopOuter = True


if __name__ == '__main__':
    options = parse_cmdline()

    # Create chandle and status ready for use
    chandle = ctypes.c_int16()
    status = {}

    # Open PicoScope 3000 Series device
    # Returns handle to chandle for use in future API functions
    status["openunit"] = ps.ps3000aOpenUnit(ctypes.byref(chandle), None)

    try:
        assert_pico_ok(status["openunit"])
    except:

        powerStatus = status["openunit"]

        if powerStatus == 286:
            status["changePowerSource"] = ps.ps3000aChangePowerSource(chandle, powerStatus)
        else:
            raise

        assert_pico_ok(status["changePowerSource"])


    # Set up channel A
    # handle = chandle
    # channel = PS3000A_CHANNEL_A = 0
    # enabled = 1
    # coupling type = PS3000A_DC = 1
    # range = PS3000A_2V = 7
    # analogue offset = 0 V
    assert ps.ps3000aSetChannel(chandle,
                                options.channel,
                                1,
                                options.coupling,
                                options.range,
                                0.0) == 0, 'Failed to setup Channel'

    # Size of capture
    sizeOfOneBuffer = 500
    numBuffersToCapture = 10

    totalSamples = sizeOfOneBuffer * numBuffersToCapture

    # Create buffers ready for assigning pointers for data collection
    bufferAMax = np.zeros(shape=sizeOfOneBuffer, dtype=np.int16)

    memory_segment = 0

    # Set data buffer location for data collection from channel A
    # handle = chandle
    # source = PS3000A_CHANNEL_A = 0
    # pointer to buffer max = ctypes.byref(bufferAMax)
    # pointer to buffer min = ctypes.byref(bufferAMin)
    # buffer length = maxSamples
    # segment index = 0
    # ratio mode = PS3000A_RATIO_MODE_NONE = 0
    assert ps.ps3000aSetDataBuffers(chandle,
                                    options.channel,
                                    bufferAMax.ctypes.data_as(ctypes.POINTER(ctypes.c_int16)),
                                    None,
                                    sizeOfOneBuffer,
                                    memory_segment,
                                    ps.PS3000A_RATIO_MODE['PS3000A_RATIO_MODE_NONE']) == 0, \
            'Failed to set data buffers for channel A'

    # Begin streaming mode:
    sampleInterval = ctypes.c_int32(250)
    sampleUnits = ps.PS3000A_TIME_UNITS['PS3000A_US']
    # We are not triggering:
    maxPreTriggerSamples = 0
    autoStopOn = 1
    # No downsampling:
    downsampleRatio = 1
    assert ps.ps3000aRunStreaming(chandle,
                                  ctypes.byref(sampleInterval),
                                  sampleUnits,
                                  maxPreTriggerSamples,
                                  totalSamples,
                                  autoStopOn,
                                  downsampleRatio,
                                  ps.PS3000A_RATIO_MODE['PS3000A_RATIO_MODE_NONE'],
                                  sizeOfOneBuffer) == 0, 'Failed to start streaming'

    actualSampleInterval = sampleInterval.value
    actualSampleIntervalNs = actualSampleInterval * 1000

    print("Capturing at sample interval %s ns" % actualSampleIntervalNs)

    # We need a big buffer, not registered with the driver, to keep our complete capture in.
    bufferCompleteA = np.zeros(shape=totalSamples, dtype=np.int16)
    nextSample = 0
    autoStopOuter = False
    wasCalledBack = False


    # Convert the python function into a C function pointer.
    cFuncPtr = ps.StreamingReadyType(streaming_callback)

    # Fetch data from the driver in a loop, copying it out of the registered buffers and into our complete one.
    while nextSample < totalSamples and not autoStopOuter:
        wasCalledBack = False
        ps.ps3000aGetStreamingLatestValues(chandle, cFuncPtr, None)
        if not wasCalledBack:
            # If we weren't called back by the driver, this means no data is ready. Sleep for a short while before trying
            # again.
            time.sleep(0.01)

    print("Done grabbing values.")

    # Find maximum ADC count value
    # handle = chandle
    # pointer to value = ctypes.byref(maxADC)
    maxADC = ctypes.c_int16()
    assert ps.ps3000aMaximumValue(chandle, ctypes.byref(maxADC)) == 0, 'Failed to find max'

    # Convert ADC counts data to mV
    adc2mVChAMax = adc2mV(bufferCompleteA, options.range, maxADC)

    # Create time data
    time = np.linspace(0, (totalSamples) * actualSampleIntervalNs, totalSamples)

    # Plot data from channel A
    plt.plot(time, adc2mVChAMax[:])
    plt.xlabel('Time (ns)')
    plt.ylabel('Voltage (mV)')
    plt.show()

    assert ps.ps3000aStop(chandle) == 0, 'Failed to stop scope'
    assert ps.ps3000aCloseUnit(chandle) == 0, 'Failed to close unit'
