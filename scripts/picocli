#!/usr/bin/env python
#
# Copyright (C) 2018-2019 Pico Technology Ltd. See LICENSE file for terms.
# Copyright (C) 2019 Xiphos Systems Corp.
#
# PS3000a Series STREAMING MODE EXAMPLE
# This example demonstrates how to call the ps3000A driver API functions in
# order to open a device, setup 2 channels and collects streamed data (1 buffer).
# This data is then plotted as mV against time in ns.

import time
import ctypes
import argparse
import numpy as np

from picosdk.constants import PICO_STATUS
from picosdk.functions import adc2mV, assert_pico_ok
from picosdk.ps3000a import ps3000a as ps
import matplotlib.pyplot as plt


class Picoscope:
    def __init__(self, serial=None):
        # Create chandle and status ready for use
        self.chandle = ctypes.c_int16()
        serial = ctypes.c_char_p(serial)

        # Open PicoScope 3000 Series device
        open_status = ps.ps3000aOpenUnit(ctypes.byref(self.chandle), serial)
        if self.chandle == -1:
            raise Exception('Failed to open scope')
        elif self.chandle == 0:
            raise Exception('Scope not found')
        # External power not found, switch to USB power
        if open_status == PICO_STATUS['PICO_POWER_SUPPLY_NOT_CONNECTED']:
            assert ps.ps3000aChangePowerSource(chandle, open_status) == 0, \
                    'Failed change power source'

        self.ds_mode = ps.PS3000A_RATIO_MODE['PS3000A_RATIO_MODE_NONE']
        self.ds_ratio = 1
        self.data_buffer = np.zeros(shape=0, dtype=np.int16)

    def set_channel(self, channel, enable=True, coupling='DC', range='2V', aoffset=0.0):
        '''Specify whether an input channel is to be enabled, its input
        coupling type, voltage range and analog offset.

        :param channel: The channel to be configured, values are: [A, B, C, D]
        :param enable: Whether or not to enable the channel, boolean
        :param coupling: The impedance and coupling type, values are:
                         - AC: 1 megohm impedance, AC coupling. The channel
                               accepts input frequencies from about 1 hertz up
                               to its maximum –3 dB analog bandwidth.
                         - DC: 1 megohm impedance, DC coupling. The scope
                               accepts all input frequencies from zero (DC) up
                               to its maximum –3 dB analog bandwidth
        :param range: The input voltage range, values are:
                      ['10MV', '20MV', '50MV', '100MV', '200MV', '500MV', '1V',
                       '2V', '5V', '10V', '20V', '50V'],
        :param aoffset: The voltage to add to the input channel before
                        digitization. The allowable range of offsets depends on
                        the input range selected for the channel, float
        '''
        assert_pico_ok(ps.ps3000aSetChannel(self.chandle,
                                    ps.PS3000A_CHANNEL[f'PS3000A_CHANNEL_{channel}'],
                                    enable,
                                    ps.PS3000A_COUPLING[f'PS3000A_{coupling}'],
                                    ps.PS3000A_RANGE[f'PS3000A_{range}'],
                                    aoffset))

    def set_downsampling_parameters(self, mode, ratio=1):
        '''Initialize downsampling parameters used by set_data_buffer and
        run_streaming

        :param mode: The downsampling mode, values are:
                     - none: Default. No downsampling, return raw data values
                     - aggregate: Reduces every block of n values to just two
                                  values: a minimum and a maximum. The minimum
                                  and maximum values are returned in two
                                  separate buffers.
                     - average: Reduces every block of n values to a single
                                value representing the average (arithmetic
                                mean) of all the values.
                     - decimate: Reduces every block of n values to just the
                                 first value in the block, discarding all the
                                 other values.
        :param ratio: The downsampling factor that will be applied to
                      the raw data
        '''
        assert mode in ['none', 'aggregate', 'average', 'decimate']
        self.ds_mode = ps.PS3000A_RATIO_MODE[f'PS3000A_RATIO_MODE_{mode}']
        self.ds_ratio = ratio

    def set_data_buffer(self, channel, size, segment=0):
        '''Tell the driver where to store the data that will be returned after
        the next call to one of the GetValues. The data can be either
        unprocessed or downsampled.

        :param channel: The channel associated to the buffer, values are: [A, B, C, D]
        :param size: The size of the overview buffer. This is a temporary
                     buffer used for storing the data before returning it to
                     the application.
        :param segment: Index of the memory segment to be used.
        '''
        self.data_buffer.resize(size)

        assert_pico_ok(ps.ps3000aSetDataBuffer(self.chandle,
                                               ps.PS3000A_CHANNEL[f'PS3000A_CHANNEL_{channel}'],
                                               self.data_buffer.ctypes.data_as(ctypes.POINTER(ctypes.c_int16)),
                                               size,
                                               segment,
                                               self.ds_mode))

    def run_streaming(self, sampling_interval, time_unit,
                      pre_trig_samples=0, post_trig_samples=0,
                      auto_stop=True):
        '''Tell the oscilloscope to start collecting data in streaming mode.
        When data has been collected from the device it is downsampled if
        necessary and then delivered to the application.

        :param sampling_interval: On entry, the requested time interval between
                                  samples, in units of time_unit;
                                  on exit, the actual time interval used.
        :param time_unit: The unit of time used for sampleInterval. Values are:
                          ['fs', 'ps', 'ns', 'us', 'ms', 's']
        :param pre_trig_samples: The maximum number of raw samples before a
                                 trigger event for each enabled channel.
        :param post_trig_samples: The maximum number of raw samples after a
                                  trigger event for each enabled channel.
        :param auto_stop: A flag that specifies if the streaming should stop
                          when all of `pre_trig_samples + post_trig_samples`
                          have been captured.
        '''

        if self.data_buffer.shape == 0:
            raise Exception('Please call set_data_buffer before run_streaming')

        assert time_unit in ['fs', 'ps', 'ns', 'us', 'ms', 's']

        size = self.data_buffer.shape[0]

        if post_trig_samples == 0:
            post_trig_samples = size * 1000

        assert_pico_ok(ps.ps3000aRunStreaming(self.chandle,
                                              ctypes.byref(sampling_interval),
                                              ps.PS3000A_TIME_UNITS[f'PS3000A_{time_unit.upper()}'],
                                              pre_trig_samples,
                                              post_trig_samples,
                                              auto_stop,
                                              self.ds_ratio,
                                              self.ds_mode,
                                              size))

    def __del__(self):
        # Stop scope from sampling data and close
        assert_pico_ok(ps.ps3000aStop(self.chandle))
        assert_pico_ok(ps.ps3000aCloseUnit(self.chandle))


def parse_cmdline():
    parser = argparse.ArgumentParser(description='Script to command a Picoscope 3000')
    parser.add_argument('--channel', default='A',
                        choices=['A', 'B', 'C', 'D'],
                        help='Set channel to sample',
    )

    ch_opts = parser.add_argument_group('channel options')
    ch_opts.add_argument('--range', default='2V',
                         choices=['10MV', '20MV', '50MV', '100MV', '200MV',
                                  '500MV', '1V', '2V', '5V', '10V', '20V',
                                  '50V'],
                         help='Set channel range',
    )
    ch_opts.add_argument('--coupling', default='DC',
                         choices=['AC', 'DC'],
                         help='Set channel coupling',
    )

    acq_opts = parser.add_argument_group('acquisition options')
    acq_opts.add_argument('--sampling-interval', type=int, default=250,
                          help='requested time interval between samples, in units of --time-unit',
    )
    acq_opts.add_argument('--time-unit', default='us',
                         choices=['fs', 'ps', 'ns', 'us', 'ms', 's'],
                         help='time unit used for sampling intervall',
    )

    options = parser.parse_args()
    options.sampling_interval = ctypes.c_int32(options.sampling_interval)

    return options


def streaming_callback(handle, noOfSamples, startIndex, overflow, triggerAt, triggered, autoStop, param):
    global nextSample, autoStopOuter, wasCalledBack
    wasCalledBack = True
    destEnd = nextSample + noOfSamples
    sourceEnd = startIndex + noOfSamples
    bufferCompleteA[nextSample:destEnd] = pico.data_buffer[startIndex:sourceEnd]
    nextSample += noOfSamples
    if autoStop:
        autoStopOuter = True


if __name__ == '__main__':
    options = parse_cmdline()

    pico = Picoscope()
    pico.set_channel(options.channel, coupling=options.coupling, range=options.range)

    # Size of capture
    sizeOfOneBuffer = 500
    numBuffersToCapture = 1000

    totalSamples = sizeOfOneBuffer * numBuffersToCapture

    pico.set_data_buffer(options.channel, sizeOfOneBuffer)

    pico.run_streaming(options.sampling_interval, options.time_unit, auto_stop=False)

    # on return, RunStreaming updates sampling_interval to the actual rate
    print(f'Actual sampling interval: {options.sampling_interval.value} {options.time_unit}')

    # We need a big buffer, not registered with the driver, to keep our complete capture in.
    bufferCompleteA = np.zeros(shape=totalSamples, dtype=np.int16)
    nextSample = 0
    autoStopOuter = False
    wasCalledBack = False


    # Convert the python function into a C function pointer.
    cFuncPtr = ps.StreamingReadyType(streaming_callback)

    # Fetch data from the driver in a loop, copying it out of the registered buffers and into our complete one.
    while nextSample < totalSamples and not autoStopOuter:
        wasCalledBack = False
        ps.ps3000aGetStreamingLatestValues(pico.chandle, cFuncPtr, None)
        if not wasCalledBack:
            # If we weren't called back by the driver, this means no data is ready. Sleep for a short while before trying
            # again.
            time.sleep(0.01)

    print("Done grabbing values.")

    # Find maximum ADC count value
    # handle = pico.chandle
    # pointer to value = ctypes.byref(maxADC)
    maxADC = ctypes.c_int16()
    assert ps.ps3000aMaximumValue(pico.chandle, ctypes.byref(maxADC)) == 0, 'Failed to find max'

    # Convert ADC counts data to mV
    adc2mVChAMax = adc2mV(bufferCompleteA,
                          ps.PS3000A_RANGE[f'PS3000A_{options.range}'],
                          maxADC)

    # Create time data
    time = np.linspace(0, (totalSamples) * options.sampling_interval.value, totalSamples)

    # Plot data from channel A
    plt.plot(time, adc2mVChAMax[:])
    plt.xlabel(f'Time ({options.time_unit})')
    plt.ylabel('Voltage (mV)')
    plt.savefig('out.png')
