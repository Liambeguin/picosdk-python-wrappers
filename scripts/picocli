#!/usr/bin/env python
# Copyright (C) 2020 Xiphos Systems Corp.

import queue
import ctypes
import struct
import argparse
import datetime
import threading

from picosdk.scope import Picoscope


def convert_si(value, uin, uout=''):
    SI = {
            'f': 1e-15,
            'p': 1e-12,
            'n': 1e-09,
            'u': 1e-06,
            'm': 1e-03,
            '' : 1e-00,
    }
    return value * SI[uin] / SI[uout]


def parse_cmdline():
    parser = argparse.ArgumentParser(description='Script to command a Picoscope 3000')
    parser.add_argument('--channel', default='A',
                        choices=['A', 'B', 'C', 'D'],
                        help='Set channel to sample',
    )
    parser.add_argument('--prefix', default='C16_samples',
                        help='Set output filename prefix',
    )

    ch_opts = parser.add_argument_group('channel options')
    ch_opts.add_argument('--range', default='2V',
                         choices=['10MV', '20MV', '50MV', '100MV', '200MV',
                                  '500MV', '1V', '2V', '5V', '10V', '20V',
                                  '50V'],
                         help='Set channel range',
    )
    ch_opts.add_argument('--coupling', default='DC',
                         choices=['AC', 'DC'],
                         help='Set channel coupling',
    )

    acq_opts = parser.add_argument_group('acquisition options')
    acq_opts.add_argument('--sampling-interval', type=int, default=250,
                          help='requested time interval between samples, in units of --time-unit',
    )
    acq_opts.add_argument('--time-unit', default='us',
                         choices=['fs', 'ps', 'ns', 'us', 'ms', 's'],
                         help='time unit used for sampling intervall',
    )
    acq_opts.add_argument('--buffer-size', type=int, default=500, metavar='N',
                           help='Set overview buffer size',
    )

    stop_opts = acq_opts.add_mutually_exclusive_group()
    stop_opts.add_argument('--count', type=int, default=1000, metavar='N',
                           help='Set number of samples to capture',
    )
    stop_opts.add_argument('--timeout', default=None, metavar='hh:mm:ss',
                           help='Set capture time',
    )

    options = parser.parse_args()
    options.sampling_interval = ctypes.c_int32(options.sampling_interval)
    options.ofile = f'{options.prefix}_{datetime.datetime.now().timestamp()}.raw'

    if options.buffer_size > options.count:
        options.buffer_size = options.count

    if options.timeout:
        # get timeout as a datetime.timedelta obj
        _timeout = datetime.datetime.combine(datetime.date.min,
                                             datetime.time.fromisoformat(options.timeout)) - \
                datetime.datetime.min
        options.count = _timeout.total_seconds() / convert_si(options.sampling_interval.value,
                                                              options.time_unit.replace('s', ''))

    return options


def streaming_callback(handle, noOfSamples, startIndex, overflow, triggerAt, triggered, autoStop, param):
    global pico
    pico.sample_count += noOfSamples
    samples = pico.overview_buffer[startIndex:startIndex+noOfSamples].copy()
    pico.queue.put(samples)


class writer(threading.Thread):
    def __init__(self, ofile, queue):
        '''worker thread to write samples to a file. The file format is 16-bit
        real followed by 16-bit imag for each sample.  The 16-bit numbers are
        stored in little endian format (least significant byte first)

        :param ofile: output file to write samples to
        :param queue: queue holding overview buffers
        '''
        threading.Thread.__init__(self)
        self.ofile = ofile
        self.queue = queue
        self.__done = False

    @property
    def done(self):
        return self.__done
    @done.setter
    def done(self, state):
        self.__done = state

    def run(self):
        with open(self.ofile, 'wb') as f:
            while not self.done:
                try:
                    item = self.queue.get(timeout=1)
                except queue.Empty:
                    pass
                data = b''
                for s in item:
                    data = data + struct.pack('<hh', s, 0)
                f.write(data)
        print(f'done writing samples to file')


if __name__ == '__main__':
    options = parse_cmdline()
    pico = Picoscope()

    writer_thread = writer(options.ofile, pico.queue)
    writer_thread.start()

    pico.set_channel(options.channel, coupling=options.coupling, range=options.range)
    pico.set_data_buffer(options.channel, options.buffer_size)

    pico.start_sampling('streaming', options.sampling_interval, options.time_unit, auto_stop=False)

    # on return, RunStreaming updates sampling_interval to the actual rate
    print(f'Actual sampling interval: {options.sampling_interval.value} {options.time_unit}')
    total_time = datetime.timedelta(seconds=options.count * \
            convert_si(options.sampling_interval.value, options.time_unit.replace('s', '')))
    print(f'Capturing {options.count} samples over {total_time}')
    print(f'Writing samples to: {options.ofile} (expected size: {16*2*options.count/(8*1e6)} MB)')

    pico.streaming_ready_cb = streaming_callback

    while pico.sample_count < options.count:
        pico.get_streaming_values()

    print("Done grabbing values.")
    writer_thread.done = True
    writer_thread.join()
